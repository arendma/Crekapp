for (i in concat_entry) {
#if there is onlyone other entry and this contains cre
entry=gsub(' ', '', unlist(strsplit(df$ProteinId[i], split=';')))
if (length(entry)==2 && any(grepl('Cre', entry))){
#remove all other entries of this protein from the data frame
rem_idx=c(rem_idx, setdiff(grep(entry[grepl('Cre', entry)], df$ProteinId, fixed = TRUE), i))
#only keep the Cre nam3e
df$ProteinId[i]=entry[grepl('Cre', entry)]
} else {
#remove this entry
rem_idx=c(rem_idx, i)
}
}
df=df[-rem_idx,]
concat_entry=grep('CpQconCAT', df$ProteinId)
test=grepl(';', df$ProteinId)
df$ProteinId[test]
#Remove all remaining entries that link to multiple proteins
# MISSING ENHANCEMT: remove measured abundance and protein names iteratively from ambigous entries
df=df[-(grep(';', df$ProteinId)),]
clean_ambig= function(df) {
#find concatamer entries
concat_entry=grep('CpQconCAT', df$ProteinId)
rem_idx=numeric()
for (i in concat_entry) {
#if there is onlyone other entry and this contains cre
entry=gsub(' ', '', unlist(strsplit(df$ProteinId[i], split=';')))
if (length(entry)==2 && any(grepl('Cre', entry))){
#remove all other entries of this protein from the data frame
rem_idx=c(rem_idx, setdiff(grep(entry[grepl('Cre', entry)], df$ProteinId, fixed = TRUE), i))
#only keep the Cre nam3e
df$ProteinId[i]=entry[grepl('Cre', entry)]
} else {
#remove this entry
rem_idx=c(rem_idx, i)
}
}
df=df[-rem_idx,]
#Remove all remaining entries that link to multiple proteins
# MISSING ENHANCEMT: remove measured abundance and protein names iteratively from ambigous entries
df=df[-(grep(';', df$ProteinId)),]
return(df)
}
QCClist=lapply(QCClist, help_f1)
QCClist=lapply(QCClist, clean_ambig)
cleaning_stat$nodup=sapply(QCClist, nrow)
QCClist=lapply(QCClist, function(df) {return(df[rowSums(is.na(df[,2:4]))<2, ])})
cleaning_stat$rep=sapply(QCClist, nrow)
#plot the cleaning statistics
c_stat_plot=cleaning_stat
for (i in 2:(ncol(c_stat_plot)-1)) {
c_stat_plot[,i]=c_stat_plot[,i]-c_stat_plot[,(i+1)]
}
colnames(c_stat_plot)[2:5]=c(colnames(c_stat_plot)[3:5], 'final')
c_stat_plot
expandcol <- function(df, cols) {
#takes a data frame and expands it by truning columns in key value pairs
if(length(cols)<dim(df)[2]) {
oldcols <- df[,-cols]
}
resdf <- data.frame()
for (i in cols) {
newdf=data.frame(oldcols,x1=df[,i], x2=rep(colnames(df)[i], dim(df)[1]))
resdf=rbind(resdf,newdf)
}
return(resdf)
}
recur_union=function(ls) {
#function that recursively builds the union of all elements in ls
if(length(ls)==1) {
return(ls[[1]])
} else {
ls[[2]]=union(ls[[1]], ls[[2]])
ls[[1]]=NULL
recur_union(ls)
}
}
SBP_QCC=read.delim('Data/QconCAT_David20201223/Proteins_Sparse_AmolPerCell.txt')
UVM_QCC=SBP_QCC[, c('ProteinId', 'UVM4_1', 'UVM4_2', 'UVM4_3')]
UVM_QCC=UVM_QCC[apply(!(is.na(UVM_QCC[, 2:4])), 1, any), ]
stop1_QCC=SBP_QCC[, grep('Protein|Stop1\\_', colnames(SBP_QCC))]
stop1_QCC=stop1_QCC[apply(!(is.na(stop1_QCC[, 2:4])), 1, any), ]
stop2_QCC=SBP_QCC[, grep('Protein|Stop12\\_', colnames(SBP_QCC))]
stop2_QCC=stop2_QCC[apply(!(is.na(stop2_QCC[, 2:4])), 1, any), ]
colnames(stop2_QCC)[2:4]=c('Stop2_1', 'Stop2_2', 'Stop2_3')
cont_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantControlTypeAnnotated.txt')
colnames(cont_QCC)=gsub('Replicate', 'control', gsub('_.amol.cell.', '', colnames(cont_QCC), fixed = TRUE))
dark_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantDarkAnnotated.txt')
colnames(dark_QCC)=gsub('Replicate', 'dark', gsub('_.amol.cell.', '', colnames(dark_QCC), fixed = TRUE))
hcell_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighCellDensityAnnotated.txt')
colnames(hcell_QCC)=gsub('Replicate', 'highcell', gsub('_.amol.cell.', '', colnames(hcell_QCC), fixed = TRUE))
hsalt_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighSaltAnnotated.txt')
colnames(hsalt_QCC)=gsub('Replicate', 'highsalt', gsub('_.amol.cell.', '', colnames(hsalt_QCC), fixed = TRUE))
htemp_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighTemperatureAnnotated.txt')
colnames(htemp_QCC)=gsub('Replicate', 'hightemp', gsub('_.amol.cell.', '', colnames(htemp_QCC), fixed = TRUE))
noshak_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantNoShakingAnnotated.txt')
colnames(noshak_QCC)=gsub('Replicate', 'noshaking', gsub('_.amol.cell.', '', colnames(noshak_QCC), fixed = TRUE))
#Cleaning the transcripts and keeping a statistic
QCClist=list(cont_QCC, dark_QCC, hcell_QCC, hsalt_QCC, htemp_QCC, noshak_QCC, UVM_QCC, stop1_QCC, stop2_QCC)
condNames=c('control', 'dark', 'highcell', 'highsalt', 'hightemp', 'noshaking', 'UVM', 'SBP_stop1', 'SBP_stop2')
rawQCClist=QCClist
#all reported protein names
cleaning_stat=data.frame(condNames, raw=sapply(QCClist, nrow))
#removing entries without Cre protein Id
QCClist=lapply(QCClist, function(df) {return(df[grepl('Cre', df[, "ProteinId"]), ])})
cleaning_stat$only_Cre=sapply(QCClist, nrow)
cleaning_stat
df=QCClist[[7]]
#find concatamer entries
concat_entry=grep('CpQconCAT', df$ProteinId)
rem_idx=numeric()
for (i in concat_entry) {
#if there is onlyone other entry and this contains cre
entry=gsub(' ', '', unlist(strsplit(df$ProteinId[i], split=';')))
if (length(entry)==2 && any(grepl('Cre', entry))){
#remove all other entries of this protein from the data frame
rem_idx=c(rem_idx, setdiff(grep(entry[grepl('Cre', entry)], df$ProteinId, fixed = TRUE), i))
#only keep the Cre nam3e
df$ProteinId[i]=entry[grepl('Cre', entry)]
} else {
#remove this entry
rem_idx=c(rem_idx, i)
}
}
df=df[-rem_idx,]
df=QCClist[[7]]
#Remove all remaining entries that link to multiple proteins
# MISSING ENHANCEMT: remove measured abundance and protein names iteratively from ambigous entries
df=df[-(grep(';', df$ProteinId)),]
clean_ambig= function(df) {
#find concatamer entries
concat_entry=grep('CpQconCAT', df$ProteinId)
rem_idx=numeric()
for (i in concat_entry) {
#if there is onlyone other entry and this contains cre
entry=gsub(' ', '', unlist(strsplit(df$ProteinId[i], split=';')))
if (length(entry)==2 && any(grepl('Cre', entry))){
#remove all other entries of this protein from the data frame
rem_idx=c(rem_idx, setdiff(grep(entry[grepl('Cre', entry)], df$ProteinId, fixed = TRUE), i))
#only keep the Cre nam3e
df$ProteinId[i]=entry[grepl('Cre', entry)]
} else {
#remove this entry
rem_idx=c(rem_idx, i)
}
}
if (length(rem_idx)!=0){
df=df[-rem_idx,]}
#Remove all remaining entries that link to multiple proteins
# MISSING ENHANCEMT: remove measured abundance and protein names iteratively from ambigous entries
df=df[-(grep(';', df$ProteinId)),]
return(df)
}
QCClist=lapply(QCClist, clean_ambig)
cleaning_stat$nodup=sapply(QCClist, nrow)
QCClist=lapply(QCClist, function(df) {return(df[rowSums(is.na(df[,2:4]))<2, ])})
cleaning_stat$rep=sapply(QCClist, nrow)
#plot the cleaning statistics
c_stat_plot=cleaning_stat
for (i in 2:(ncol(c_stat_plot)-1)) {
c_stat_plot[,i]=c_stat_plot[,i]-c_stat_plot[,(i+1)]
}
colnames(c_stat_plot)[2:5]=c(colnames(c_stat_plot)[3:5], 'final')
c_stat_plot
c_stat_plot=expandcol(c_stat_plot, 2:5)
colnames(c_stat_plot)=c('Condition', 'value', 'step')
c_stat_plot$step=factor(c_stat_plot$step, levels=c('only_Cre', 'nodup', 'rep', 'final'))
filtplot=ggplot(c_stat_plot, aes(fill=step, y=value, x=Condition)) + geom_bar(position='stack', stat='identity') +
theme_bw()+theme(text=element_text(size=20), axis.text.x=element_text(angle=45, hjust = 1))
ggsave('Results/QconCat20220124/filter_plot.pdf', width=10, height = 6,useDingbats=FALSE)
# Script for the summary statistics of Davids QConCat data 20220124
read_qcc=function() {
#Reads in  data from QCC experiments and cleans of ambigous gene names and proteins only observed in a single biological replicate
require(ggplot2)
expandcol <- function(df, cols) {
#takes a data frame and expands it by truning columns in key value pairs
if(length(cols)<dim(df)[2]) {
oldcols <- df[,-cols]
}
resdf <- data.frame()
for (i in cols) {
newdf=data.frame(oldcols,x1=df[,i], x2=rep(colnames(df)[i], dim(df)[1]))
resdf=rbind(resdf,newdf)
}
return(resdf)
}
recur_union=function(ls) {
#function that recursively builds the union of all elements in ls
if(length(ls)==1) {
return(ls[[1]])
} else {
ls[[2]]=union(ls[[1]], ls[[2]])
ls[[1]]=NULL
recur_union(ls)
}
}
SBP_QCC=read.delim('Data/QconCAT_David20201223/Proteins_Sparse_AmolPerCell.txt')
UVM_QCC=SBP_QCC[, c('ProteinId', 'UVM4_1', 'UVM4_2', 'UVM4_3')]
UVM_QCC=UVM_QCC[apply(!(is.na(UVM_QCC[, 2:4])), 1, any), ]
stop1_QCC=SBP_QCC[, grep('Protein|Stop1\\_', colnames(SBP_QCC))]
stop1_QCC=stop1_QCC[apply(!(is.na(stop1_QCC[, 2:4])), 1, any), ]
stop2_QCC=SBP_QCC[, grep('Protein|Stop12\\_', colnames(SBP_QCC))]
stop2_QCC=stop2_QCC[apply(!(is.na(stop2_QCC[, 2:4])), 1, any), ]
colnames(stop2_QCC)[2:4]=c('Stop2_1', 'Stop2_2', 'Stop2_3')
cont_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantControlTypeAnnotated.txt')
colnames(cont_QCC)=gsub('Replicate', 'control', gsub('_.amol.cell.', '', colnames(cont_QCC), fixed = TRUE))
dark_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantDarkAnnotated.txt')
colnames(dark_QCC)=gsub('Replicate', 'dark', gsub('_.amol.cell.', '', colnames(dark_QCC), fixed = TRUE))
hcell_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighCellDensityAnnotated.txt')
colnames(hcell_QCC)=gsub('Replicate', 'highcell', gsub('_.amol.cell.', '', colnames(hcell_QCC), fixed = TRUE))
hsalt_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighSaltAnnotated.txt')
colnames(hsalt_QCC)=gsub('Replicate', 'highsalt', gsub('_.amol.cell.', '', colnames(hsalt_QCC), fixed = TRUE))
htemp_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighTemperatureAnnotated.txt')
colnames(htemp_QCC)=gsub('Replicate', 'hightemp', gsub('_.amol.cell.', '', colnames(htemp_QCC), fixed = TRUE))
noshak_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantNoShakingAnnotated.txt')
colnames(noshak_QCC)=gsub('Replicate', 'noshaking', gsub('_.amol.cell.', '', colnames(noshak_QCC), fixed = TRUE))
#Cleaning the transcripts and keeping a statistic
QCClist=list(cont_QCC, dark_QCC, hcell_QCC, hsalt_QCC, htemp_QCC, noshak_QCC, UVM_QCC, stop1_QCC, stop2_QCC)
condNames=c('control', 'dark', 'highcell', 'highsalt', 'hightemp', 'noshaking', 'UVM', 'SBP_stop1', 'SBP_stop2')
rawQCClist=QCClist
#all reported protein names
cleaning_stat=data.frame(condNames, raw=sapply(QCClist, nrow))
#removing entries without Cre protein Id
QCClist=lapply(QCClist, function(df) {return(df[grepl('Cre', df[, "ProteinId"]), ])})
cleaning_stat$only_Cre=sapply(QCClist, nrow)
# #save a table with the logicals indicating if a protein was measured in the given condition - for NIDLE
# measured_prot=lapply(QCClist, function(df){return(unique(gsub(' ', '', unlist(strsplit(df$ProteinId, split=';')))))})
# all_prot=recur_union(measured_prot)
# report_tab=data.frame(all_prot, sapply(measured_prot, function(x) {return(all_prot %in% x)}))
# colnames(report_tab)=c('ProteinId', condNames)
# write.table(report_tab, 'Results/QconCat20220124/isexpressed.tsv', row.names=FALSE, sep='\t')
#remove any entry with a duplicated protein
clean_ambig= function(df) {
#find concatamer entries
concat_entry=grep('CpQconCAT', df$ProteinId)
rem_idx=numeric()
for (i in concat_entry) {
#if there is onlyone other entry and this contains cre
entry=gsub(' ', '', unlist(strsplit(df$ProteinId[i], split=';')))
if (length(entry)==2 && any(grepl('Cre', entry))){
#remove all other entries of this protein from the data frame
rem_idx=c(rem_idx, setdiff(grep(entry[grepl('Cre', entry)], df$ProteinId, fixed = TRUE), i))
#only keep the Cre nam3e
df$ProteinId[i]=entry[grepl('Cre', entry)]
} else {
#remove this entry
rem_idx=c(rem_idx, i)
}
}
if (length(rem_idx)!=0){
df=df[-rem_idx,]}
#Remove all remaining entries that link to multiple proteins
# MISSING ENHANCEMT: remove measured abundance and protein names iteratively from ambigous entries
df=df[-(grep(';', df$ProteinId)),]
return(df)
}
QCClist=lapply(QCClist, clean_ambig)
cleaning_stat$nodup=sapply(QCClist, nrow)
#remove any entries with more than 1 nan value
QCClist=lapply(QCClist, function(df) {return(df[rowSums(is.na(df[,2:4]))<2, ])})
cleaning_stat$rep=sapply(QCClist, nrow)
#plot the cleaning statistics
c_stat_plot=cleaning_stat
for (i in 2:(ncol(c_stat_plot)-1)) {
c_stat_plot[,i]=c_stat_plot[,i]-c_stat_plot[,(i+1)]
}
colnames(c_stat_plot)[2:5]=c(colnames(c_stat_plot)[3:5], 'final')
c_stat_plot=expandcol(c_stat_plot, 2:5)
colnames(c_stat_plot)=c('Condition', 'value', 'step')
c_stat_plot$step=factor(c_stat_plot$step, levels=c('only_Cre', 'nodup', 'rep', 'final'))
filtplot=ggplot(c_stat_plot, aes(fill=step, y=value, x=Condition)) + geom_bar(position='stack', stat='identity') +
theme_bw()+theme(text=element_text(size=20), axis.text.x=element_text(angle=45, hjust = 1))
ggsave('Results/QconCat20220124/filter_plot.pdf', width=10, height = 6,useDingbats=FALSE)
return(list(QCClist, rawQCClist))
}
qccdat=read_qcc()[[1]]
#Function to calculate and plot overview statistics for QCC data
#Input:
# - qccdat: data frame with mearused trancript/protein names as rownames
library(ggplot2)
library(ggfortify)
source('dircreater.r', local=TRUE)
#Import Cre1355 GPR matrix (the set of genes in Cre1355 is a subset of CreMora)
Cre1355gxn=as.matrix(read.delim('Data/Cre1355/Cre1355_transcripts.txt', row.names = 1))
recurmerge=function(QCClist) {
#funcion to recursively merge the QCC data frames
if (length(QCClist)==1) {
return(QCClist[[1]])
} else {
QCClist[[2]]=merge(QCClist[[1]], QCClist[[2]], by=1, all=TRUE)
QCClist[[1]]=NULL
recurmerge(QCClist)
}
}
#remove synonyme column
qccdat=lapply(qccdat, function(df) {return(df[, !(colnames(df)%in% "Synonym")])})
#merge together all cleaned data frames THBERE ARE NEW AMBIGOUTIES INTRODUCED HERE but for each sample no ambiguities are garantied (NA for ambigous value)
QCCagg=recurmerge(qccdat)
help_f2=function (x,df){
dfslice=df[, grep(x, colnames(df), fixed=TRUE)]
if (any(rowSums(is.na(dfslice))==2)) {
stop(paste('Cases with only one maesurement in triplicates detected for condition', x))
}
return(apply(dfslice, 1, median, na.rm=TRUE))
}
med_QCCagg=sapply(unique(gsub('_[[:digit:]]', '', colnames(QCCagg)[2:ncol(QCCagg)])), help_f2, df=QCCagg)
sum_stat=data.frame(sample=gsub('_[[:digit:]]', '', colnames(QCCagg)[2:ncol(QCCagg)]) , tot_amol=colSums(QCCagg[,2:ncol(QCCagg)], na.rm = TRUE))
#get proteins included in the model (here a single match in gene names is ok)
cre_idx=rowSums(sapply(colnames(Cre1355gxn), grepl, x=QCCagg$ProteinId, fixed=TRUE))>0
sum_stat=cbind(sum_stat, cre_amol=colSums(QCCagg[cre_idx,2:ncol(QCCagg)], na.rm = TRUE))
cre_QCCagg=QCCagg[cre_idx,]
plot1=ggplot(data=sum_stat, aes(x=sample, y=tot_amol)) + stat_summary(fun.y=mean, geom='bar', alpha=0.4) + geom_point() + labs(y='Total Protein content [amol/cell]') +
stat_summary(aes(y=cre_amol), fun.y=mean, geom='bar', fill='lightpink3') + geom_point(aes(y=cre_amol), color='red') +  theme_bw(base_size=14)
ggsave('Results/QconCat20220124/tot_prot.pdf')
#limit on fully measured proteins
ns_QCCagg=QCCagg[rowSums(is.na(QCCagg))==0,]
ns_cre_QCCagg=cre_QCCagg[rowSums(is.na(cre_QCCagg))==0, ]
pca1 <- prcomp(t(log2(ns_QCCagg[,2:ncol(QCCagg)])))
bp1 <- autoplot(pca1, data=sum_stat,colour='sample' ,size=5) + theme_bw()+theme(text=element_text(size=25)) + labs(colour='Sample')
ggsave('Results/QconCat20220124/pca_full.pdf', bp1)
pca2 <- prcomp(t(log2(ns_cre_QCCagg[,2:ncol(QCCagg)])))
bp2 <- autoplot(pca2, data=sum_stat,colour='sample' ,size=5) + theme_bw()+theme(text=element_text(size=25)) + labs(colour='Sample')
ggsave('Results/QconCat20220124/pca_full_cre.pdf', bp2)
#export the median abundance for use with NIDLE
write.table(med_QCCagg, 'Data/QconCAT_David20220124/abs_abundance/med_abun_all.tsv', row.names=FALSE, sep='\ŧ')
#export the median abundance for use with NIDLE
write.table(med_QCCagg, 'Data/QconCAT_David20220124/abs_abundance/med_abun_all.tsv', row.names=FALSE, sep='\t')
setwd("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355")
# if(.Platform$OS.type == "unix") {
#   setwd("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355/")
# } else {
#   setwd("C:/Users/Suiram/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355/")
# }
#Script to fit a linear model to predict acetate upatke from mu
#Data extracted from publication:
mu=c(0.082, 0.082, 0.061, 0.061)
nh4up=c(3.035, 0.748, 1.259, 1.071)
po4up=c(0.099, 0.078, 0.047, 0.041)
acup=c(1.364, 2.261, 1.059, 1.234)
saheed_dat=data.frame(mu, nh4up, po4up, acup)
mod1=lm(acup ~mu, saheed_dat)
print(summary(mod1))
print('using a linear model for mu=0.0937 the predicted uptake rate is')
#Experimental growth rates
proteomics_dat=data.frame(Condition=c('Stop1', 'Stop2', 'UVM4', 'Control', 'HighCell', 'Highsalt', 'Hightemp', 'Noshaking'),
mu=c(0.0864,0.0837, 0.0937,0.11, 0.02, 0.02, 0.02, 0.04))
pred=predict(mod1, proteomics_dat , se.fit=TRUE)
proteomics_dat$pred_acup=pred$fit+pred$se.fit
rbind(proteomics_dat, c('Dark', '0.02', '1.6'))
#only set light for dark to zero, otherwise take default alvue
proteomics_dat$lightup=c(rep(80, 8), 0)
proteomics_dat
proteomics_dat=rbind(proteomics_dat, c('Dark', '0.02', '1.6'))
#only set light for dark to zero, otherwise take default alvue
proteomics_dat$lightup=c(rep(80, 8), 0)
proteomics_dat
write.table(proteomics_dat, '../../Data/QconCAT_David20220124/fitted_acup.tsv', row.names=FALSE, sep='\t')
proteomics_dat
setwd("~/Nextcloud/PhD/Project_Silgreen/silgreen_code")
# Script for the summary statistics of Davids QConCat data 20220124
read_qcc=function() {
#Reads in  data from QCC experiments and cleans of ambigous gene names and proteins only observed in a single biological replicate
require(ggplot2)
expandcol <- function(df, cols) {
#takes a data frame and expands it by truning columns in key value pairs
if(length(cols)<dim(df)[2]) {
oldcols <- df[,-cols]
}
resdf <- data.frame()
for (i in cols) {
newdf=data.frame(oldcols,x1=df[,i], x2=rep(colnames(df)[i], dim(df)[1]))
resdf=rbind(resdf,newdf)
}
return(resdf)
}
recur_union=function(ls) {
#function that recursively builds the union of all elements in ls
if(length(ls)==1) {
return(ls[[1]])
} else {
ls[[2]]=union(ls[[1]], ls[[2]])
ls[[1]]=NULL
recur_union(ls)
}
}
SBP_QCC=read.delim('Data/QconCAT_David20201223/Proteins_Sparse_AmolPerCell.txt')
UVM_QCC=SBP_QCC[, c('ProteinId', 'UVM4_1', 'UVM4_2', 'UVM4_3')]
UVM_QCC=UVM_QCC[apply(!(is.na(UVM_QCC[, 2:4])), 1, any), ]
stop1_QCC=SBP_QCC[, grep('Protein|Stop1\\_', colnames(SBP_QCC))]
stop1_QCC=stop1_QCC[apply(!(is.na(stop1_QCC[, 2:4])), 1, any), ]
stop2_QCC=SBP_QCC[, grep('Protein|Stop12\\_', colnames(SBP_QCC))]
stop2_QCC=stop2_QCC[apply(!(is.na(stop2_QCC[, 2:4])), 1, any), ]
colnames(stop2_QCC)[2:4]=c('Stop2_1', 'Stop2_2', 'Stop2_3')
cont_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantControlTypeAnnotated.txt')
colnames(cont_QCC)=gsub('Replicate', 'control', gsub('_.amol.cell.', '', colnames(cont_QCC), fixed = TRUE))
dark_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantDarkAnnotated.txt')
colnames(dark_QCC)=gsub('Replicate', 'dark', gsub('_.amol.cell.', '', colnames(dark_QCC), fixed = TRUE))
hcell_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighCellDensityAnnotated.txt')
colnames(hcell_QCC)=gsub('Replicate', 'highcell', gsub('_.amol.cell.', '', colnames(hcell_QCC), fixed = TRUE))
hsalt_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighSaltAnnotated.txt')
colnames(hsalt_QCC)=gsub('Replicate', 'highsalt', gsub('_.amol.cell.', '', colnames(hsalt_QCC), fixed = TRUE))
htemp_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantHighTemperatureAnnotated.txt')
colnames(htemp_QCC)=gsub('Replicate', 'hightemp', gsub('_.amol.cell.', '', colnames(htemp_QCC), fixed = TRUE))
noshak_QCC=read.delim('Data/QconCAT_David20220124/abs_abundance/AbsoluteQuantNoShakingAnnotated.txt')
colnames(noshak_QCC)=gsub('Replicate', 'noshaking', gsub('_.amol.cell.', '', colnames(noshak_QCC), fixed = TRUE))
#Cleaning the transcripts and keeping a statistic
QCClist=list(cont_QCC, dark_QCC, hcell_QCC, hsalt_QCC, htemp_QCC, noshak_QCC, UVM_QCC, stop1_QCC, stop2_QCC)
condNames=c('control', 'dark', 'highcell', 'highsalt', 'hightemp', 'noshaking', 'UVM', 'SBP_stop1', 'SBP_stop2')
rawQCClist=QCClist
#all reported protein names
cleaning_stat=data.frame(condNames, raw=sapply(QCClist, nrow))
#removing entries without Cre protein Id
QCClist=lapply(QCClist, function(df) {return(df[grepl('Cre', df[, "ProteinId"]), ])})
cleaning_stat$only_Cre=sapply(QCClist, nrow)
# #save a table with the logicals indicating if a protein was measured in the given condition - for NIDLE
# measured_prot=lapply(QCClist, function(df){return(unique(gsub(' ', '', unlist(strsplit(df$ProteinId, split=';')))))})
# all_prot=recur_union(measured_prot)
# report_tab=data.frame(all_prot, sapply(measured_prot, function(x) {return(all_prot %in% x)}))
# colnames(report_tab)=c('ProteinId', condNames)
# write.table(report_tab, 'Results/QconCat20220124/isexpressed.tsv', row.names=FALSE, sep='\t')
#remove any entry with a duplicated protein
clean_ambig= function(df) {
#find concatamer entries
concat_entry=grep('CpQconCAT', df$ProteinId)
rem_idx=numeric()
for (i in concat_entry) {
#if there is onlyone other entry and this contains cre
entry=gsub(' ', '', unlist(strsplit(df$ProteinId[i], split=';')))
if (length(entry)==2 && any(grepl('Cre', entry))){
#remove all other entries of this protein from the data frame
rem_idx=c(rem_idx, setdiff(grep(entry[grepl('Cre', entry)], df$ProteinId, fixed = TRUE), i))
#only keep the Cre nam3e
df$ProteinId[i]=entry[grepl('Cre', entry)]
} else {
#remove this entry
rem_idx=c(rem_idx, i)
}
}
if (length(rem_idx)!=0){
df=df[-rem_idx,]}
#Remove all remaining entries that link to multiple proteins
# MISSING ENHANCEMT: remove measured abundance and protein names iteratively from ambigous entries
df=df[-(grep(';', df$ProteinId)),]
return(df)
}
QCClist=lapply(QCClist, clean_ambig)
cleaning_stat$nodup=sapply(QCClist, nrow)
#remove any entries with more than 1 nan value
QCClist=lapply(QCClist, function(df) {return(df[rowSums(is.na(df[,2:4]))<2, ])})
cleaning_stat$rep=sapply(QCClist, nrow)
#plot the cleaning statistics
c_stat_plot=cleaning_stat
for (i in 2:(ncol(c_stat_plot)-1)) {
c_stat_plot[,i]=c_stat_plot[,i]-c_stat_plot[,(i+1)]
}
colnames(c_stat_plot)[2:5]=c(colnames(c_stat_plot)[3:5], 'final')
c_stat_plot=expandcol(c_stat_plot, 2:5)
colnames(c_stat_plot)=c('Condition', 'value', 'step')
c_stat_plot$step=factor(c_stat_plot$step, levels=c('only_Cre', 'nodup', 'rep', 'final'))
filtplot=ggplot(c_stat_plot, aes(fill=step, y=value, x=Condition)) + geom_bar(position='stack', stat='identity') +
theme_bw()+theme(text=element_text(size=20), axis.text.x=element_text(angle=45, hjust = 1))
ggsave('Results/QconCat20220124/filter_plot.pdf', width=10, height = 6,useDingbats=FALSE)
return(list(QCClist, rawQCClist))
}
qccdat=read_qcc()[[1]]
#Function to calculate and plot overview statistics for QCC data
#Input:
# - qccdat: data frame with mearused trancript/protein names as rownames
library(ggplot2)
library(ggfortify)
#Import Cre1355 GPR matrix (the set of genes in Cre1355 is a subset of CreMora)
Cre1355gxn=as.matrix(read.delim('Data/Cre1355/Cre1355_transcripts.txt', row.names = 1))
recurmerge=function(QCClist) {
#funcion to recursively merge the QCC data frames
if (length(QCClist)==1) {
return(QCClist[[1]])
} else {
QCClist[[2]]=merge(QCClist[[1]], QCClist[[2]], by=1, all=TRUE)
QCClist[[1]]=NULL
recurmerge(QCClist)
}
}
#remove synonyme column
qccdat=lapply(qccdat, function(df) {return(df[, !(colnames(df)%in% "Synonym")])})
#merge together all cleaned data frames THBERE ARE NEW AMBIGOUTIES INTRODUCED HERE but for each sample no ambiguities are garantied (NA for ambigous value)
QCCagg=recurmerge(qccdat)
help_f2=function (x,df){
dfslice=df[, grep(x, colnames(df), fixed=TRUE)]
if (any(rowSums(is.na(dfslice))==2)) {
stop(paste('Cases with only one maesurement in triplicates detected for condition', x))
}
return(apply(dfslice, 1, median, na.rm=TRUE))
}
med_QCCagg=sapply(unique(gsub('_[[:digit:]]', '', colnames(QCCagg)[2:ncol(QCCagg)])), help_f2, df=QCCagg)
head(med_QCCagg)
med_QCCagg$ProteinId=QCCagg$ProteinId
med_QCCagg=sapply(unique(gsub('_[[:digit:]]', '', colnames(QCCagg)[2:ncol(QCCagg)])), help_f2, df=QCCagg)
QCCagg$ProteinId
length(QCCagg$ProteinId)
med_QCCagg$ProteinId=QCCagg$ProteinId
med_QCCagg=sapply(unique(gsub('_[[:digit:]]', '', colnames(QCCagg)[2:ncol(QCCagg)])), help_f2, df=QCCagg)
med_QCCagg=data.frame(ProteinId=QCCagg$ProteinId, med_QCCagg)
med_QCCagg
head(med_QCCagg)
med_QCCagg$ProteinId[1:50]
med_QCCagg$ProteinId[1:100]
write.table(med_QCCagg, 'Data/QconCAT_David20220124/abs_abundance/med_abun_all.tsv', row.names=FALSE, sep='\t')
setwd("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355")
source("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355/fit_chemostatdat.r")
source("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355/fit_chemostatdat.r")
source("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355/fit_chemostatdat.r")
source("~/Nextcloud/PhD/Project_Silgreen/silgreen_code/Data/Cre1355/fit_chemostatdat.r")
